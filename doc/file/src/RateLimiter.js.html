<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/RateLimiter.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="git+ssh://git@github.com/endlist/simple-limiter.git">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RateLimiter.js~RateLimiter.html">RateLimiter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TokenBucket.js~TokenBucket.html">TokenBucket</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/RateLimiter.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

const TokenBucket = require(&apos;./TokenBucket&apos;);
const _           = require(&apos;lodash&apos;);

/**
 * RateLimiter Class
 *
 * Handles creation and destruction of TokenBuckets by key.
 */
class RateLimiter {

  /**
   * Creates a RateLimiter object.
   *
   * @param {object} config configuration values
   * @param {integer} config.limit The max amount of tokens per incrementInterval.
   * @param {integer} config.incrementInterval The time in ms before tokens will increment.
   * @param {integer} config.increment The amount of tokens that will increment each incrementInterval.
   */
  constructor(config) {
    let limit             = null;
    let incrementInterval = null;
    let increment         = null;

    if (config != null) {
      limit             = config.limit;
      incrementInterval = config.incrementInterval;
      increment         = config.increment;
    }

    this.config = { limit, incrementInterval, increment };
    this.tokenBuckets = {};

    this._interval = setInterval(() =&gt; {
      this._cleanup();
    }, incrementInterval);
  }

  /**
   * Cleans up unused TokenBuckets
   */
  _cleanup() {
    _.each(this.tokenBuckets, (value, key) =&gt; {
      const tokenBucket = this.tokenBuckets[key];
      if (tokenBucket.tokens == tokenBucket.limit) {
        tokenBucket.destroy();
        delete this.tokenBuckets[key];
      }
    });
  }

  /**
   * Cleans up all TokenBuckets and nulls the array.
   */
  destroy() {
    _.each(this.tokenBuckets, (value, key) =&gt; {
      this.tokenBuckets[key].destroy();
      delete this.tokenBuckets[key];
    });
  }

  /**
   * Helper to throw an error if the key is invalid.
   *
   * @param {key} key The identifier for the request
   * @throws {Error} throw error when key is invalid
   * @private
   */
  _errorCheckForKey(key) {
    if (key == null) {
      throw new Error(&apos;key is required&apos;);
    }
    else if(typeof(key) != &apos;string&apos;) {
      throw new Error(&apos;key is not a string&apos;);
    }
  }

  /**
   * Helper to create a new TokenBucket if needed.
   *
   * @param {string} key The identifier for the request
   * @private
   */
  _getTokenBucket(key) {
    this._errorCheckForKey(key);

    if (this.tokenBuckets[key] == null) {
      const limit = this.config.limit;
      const increment = this.config.increment;
      const incrementInterval = this.config.incrementInterval;

      this.tokenBuckets[key] = new TokenBucket({ limit, increment, incrementInterval });
    }

    return this.tokenBuckets[key];
  }

  /**
   * Appropriately decrements the remaining token availability
   * when called and returns the remainder.
   *
   * @param {string} key The identifier for the request
   * @param {integer} [amount] The number to decrement by
   * @return {integer} Remaining request count
   */
  decrementTokens(key, amount) {
    const tokenBucket = this._getTokenBucket(key);

    return tokenBucket.decrementTokens(amount);
  }

  /**
   * Returns the remaining request count for the given key.
   * If the key doesn&apos;t already exist, it will create it.
   *
   * @param {string} key The identifier for the request
   * @return {integer} Remaining request count
   */
  getTokensRemaining(key) {
    const tokenBucket = this._getTokenBucket(key);

    return tokenBucket.getTokensRemaining();
  }

}

module.exports = RateLimiter;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
